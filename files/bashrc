if shopt -q login_shell ; then # login shell
    export LANG="UTF-8"
    export LANGUAGE="en_US.UTF-8"
    export LC_ALL="en_US.UTF-8"

    export GOPATH="$HOME/go"
    export PATH="$GOPATH/bin:$HOME/bin:/usr/local/bin:/usr/local/sbin:/usr/local/share/npm/bin:$PATH"

    [ -n "$(which vi)" ] && export EDITOR="$(which vi)"
fi


if [ -n "$PS1" ]; then  # interactive-shell

    # Save multiline command in history
    shopt -s cmdhist
    shopt -s lithist

    # aliases
    alias ..="cd .."
    alias ...="cd ../.."
    alias ....="cd ../../.."
    alias ll="ls -lh"
    alias la="ls -ha"
    alias lla="ls -lha"
    alias grep="grep --color=auto"
    alias egrep="egrep --color=auto"
    alias g="git add -A"
    alias gg="git add -A && git commit"
    alias ggg="git add -A && git commit && git push"
    alias ipy="ipython"
    alias bpy="bpython"
    alias py="python"
    alias tree="tree -C"
    alias vbox='VBoxManage'

    case "$(uname)" in 
        Darwin)
            # color ls output
            export CLICOLOR=1
            alias l="ls -CF"
            ;;
        Linux)
            alias ls="ls --color=auto"
            alias l="ls -CF --hide=*.pyc"
            ;;
        *)
    esac


    if [ "$TERM_PROGRAM" = "iTerm.app" ]; then
        # switch iTerm2 profiles
        i2p() {
            case "$1" in
                l*)
                    echo -e "\033]50;SetProfile=SolarizedLight\a"
                    export ITERM_PROFILE='SolarizedLight'
                    export COLORFGBG='11;15'
                    ;;
                d*)
                    echo -e "\033]50;SetProfile=SolarizedDark\a"
                    export ITERM_PROFILE='SolarizedDark'
                    export COLORFGBG='12;8'
                    ;;
                *)
                    echo "Switch iTerm2 profile"
                    echo "Usage: $FUNCNAME [dark|light]"
            esac
        }
    fi

    # zsh-style preexec function which execute before each command
    #preexec () { 
    #    :;
    #}

    #preexec_invoke_exec () {
    #    [ -n "$COMP_LINE" ] && return  # do nothing if completing
    #    [ "$BASH_COMMAND" = "$PROMPT_COMMAND" ] && return # don't cause a preexec for $PROMPT_COMMAND
    #    local this_command=`history 1 | sed -e "s/^[ ]*[0-9]*[ ]*//g"`;
    #    preexec "$this_command"
    #}
    #trap 'preexec_invoke_exec' DEBUG

    [ -f ~/Projects/bash-powerline/bash-powerline.sh ] && source ~/Projects/bash-powerline/bash-powerline.sh
    [ -f /etc/bash_completion ] && source /etc/bash_completion
    [ -f /usr/local/etc/bash_completion ] && source /usr/local/etc/bash_completion
fi
